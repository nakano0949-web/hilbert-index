<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>HilbertIndex2D 可視化</title>
<style>
  body { background: #222; color: #eee; font-family: sans-serif; }
  canvas { background: #000; display: block; margin: 20px auto; }
</style>
</head>
<body>

<h2>HilbertIndex2D 可視化</h2>
<p>ドラッグで矩形を動かすと、range の結果が赤く表示されます。</p>

<canvas id="cv" width="512" height="512"></canvas>

<script>
// =========================
// HilbertIndex2D 本体
// =========================

class HilbertIndex2D {
  constructor(order) {
    this.order = order;
    this.items = [];
  }

  insert(x, y, value) {
    const h = hilbertXY2D(this.order, x, y);
    this.items.push({ h, x, y, value });
    return this;
  }

  build() {
    this.items.sort((a, b) => a.h - b.h);
  }

  range(rect) {
    const ranges = hilbertRange(this.order, rect);
    const results = [];

    for (const [hMin, hMax] of ranges) {
      const start = lowerBound(this.items, hMin);
      const end = upperBound(this.items, hMax);

      for (let i = start; i < end; i++) {
        const p = this.items[i];
        if (
          p.x >= rect.x0 &&
          p.x <= rect.x1 &&
          p.y >= rect.y0 &&
          p.y <= rect.y1
        ) {
          results.push(p);
        }
      }
    }
    return results;
  }
}

// =========================
// Hilbert 補助関数
// =========================

function hilbertXY2D(order, x, y) {
  let h = 0;
  for (let i = order - 1; i >= 0; i--) {
    const rx = (x >> i) & 1;
    const ry = (y >> i) & 1;
    h += (1 << (2 * i)) * ((3 * rx) ^ ry);
    if (ry === 0) {
      if (rx === 1) {
        x = (1 << order) - 1 - x;
        y = (1 << order) - 1 - y;
      }
      [x, y] = [y, x];
    }
  }
  return h;
}

function lowerBound(arr, h) {
  let l = 0, r = arr.length;
  while (l < r) {
    const m = (l + r) >> 1;
    if (arr[m].h < h) l = m + 1;
    else r = m;
  }
  return l;
}

function upperBound(arr, h) {
  let l = 0, r = arr.length;
  while (l < r) {
    const m = (l + r) >> 1;
    if (arr[m].h <= h) l = m + 1;
    else r = m;
  }
  return l;
}

function hilbertRange(order, rect) {
  const max = 1 << order;
  const ranges = [];

  function recurse(x0, y0, size, h0) {
    const x1 = x0 + size - 1;
    const y1 = y0 + size - 1;

    if (x1 < rect.x0 || x0 > rect.x1 || y1 < rect.y0 || y0 > rect.y1) return;

    if (x0 >= rect.x0 && x1 <= rect.x1 && y0 >= rect.y0 && y1 <= rect.y1) {
      const h1 = h0 + size * size - 1;
      ranges.push([h0, h1]);
      return;
    }

    const half = size >> 1;
    if (half === 0) return;

    recurse(x0,        y0,        half, h0);
    recurse(x0,        y0+half,   half, h0 + half*half);
    recurse(x0+half,   y0+half,   half, h0 + 2*half*half);
    recurse(x0+half,   y0,        half, h0 + 3*half*half);
  }

  recurse(0, 0, max, 0);
  return ranges;
}

// =========================
// データ生成 & Canvas 可視化
// =========================

const idx = new HilbertIndex2D(8);
const points = [];

for (let i = 0; i < 30000; i++) {
  const x = Math.random() * 256 | 0;
  const y = Math.random() * 256 | 0;
  points.push({ x, y });
  idx.insert(x, y, i);
}
idx.build();

const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");
const scale = 2;

let rect = { x0: 50, y0: 50, x1: 150, y1: 150 };
let dragging = false;

cv.addEventListener("mousedown", () => dragging = true);
cv.addEventListener("mouseup",   () => dragging = false);
cv.addEventListener("mouseleave", () => dragging = false);

cv.addEventListener("mousemove", e => {
  if (!dragging) return;

  const r = cv.getBoundingClientRect();
  const mx = (e.clientX - r.left) / scale;
  const my = (e.clientY - r.top) / scale;

  const w = rect.x1 - rect.x0;
  const h = rect.y1 - rect.y0;

  rect.x0 = mx - w/2;
  rect.y0 = my - h/2;
  rect.x1 = rect.x0 + w;
  rect.y1 = rect.y0 + h;

  draw();
});

function draw() {
  ctx.clearRect(0, 0, cv.width, cv.height);

  ctx.fillStyle = "white";
  for (const p of points) {
    ctx.fillRect(p.x * scale, p.y * scale, 2, 2);
  }

  const hits = idx.range(rect);
  ctx.fillStyle = "red";
  for (const p of hits) {
    ctx.fillRect(p.x * scale, p.y * scale, 2, 2);
  }

  ctx.strokeStyle = "yellow";
  ctx.strokeRect(rect.x0 * scale, rect.y0 * scale,
                 (rect.x1 - rect.x0) * scale,
                 (rect.y1 - rect.y0) * scale);
}

draw();
</script>

</body>
</html>